<!DOCTYPE html>
<html>
<head style="margin-top: auto;">
	<title>Algoritmos Voraces</title>
	<style>
		/* Estilos CSS para el navigation bar */
		nav {
			background-color: #333;
			overflow: hidden;
		}
		
		nav a {
			float: left;
			color: white;
			text-align: center;
			padding: 14px 16px;
			text-decoration: none;
		}
		
		nav a:hover {
			background-color: #ddd;
			color: black;
		}

		/* Estilos CSS para los divs de información */
		.info {
			display: none;
			padding: 20px;
			
		}

		/* Estilos CSS para el header */
		header {
			background-color: #0077b6;
			color: white;
			text-align: center;
			padding: 20px;
			border: none;
		}
		/* Función para alinear imagen a la derecha */
		.right-image {
			display: flex;
			flex-direction: row-reverse;
			align-items: right;
}
	#algoritmos-dijkstra .text-container {
		display: flex;
		}
		#algoritmos-dijkstra .text-container p {
			flex-grow: 1;
		}
		#Floyd-Warshall .text-container {
		display: flex;
		}
		#Floyd-Warshall .text-container p {
			flex-grow: 1;
		}
		#algoritmos-prim .text-container {
		display: flex;
		}
		#algoritmos-prim .text-container p {
			flex-grow: 1;
		}
		#algoritmos-kruskal .text-container {
		display: flex;
		}
		#algoritmos-kruskal .text-container p {
			flex-grow: 1;
		}
		#algoritmo-de-fuerza-bruta .text-container {
		display: flex;
		}
		#algoritmo-de-fuerza-bruta.text-container p {
			flex-grow: 1;
		}
		#algoritmo-Divide-vencerás .text-container {
		display: flex;
		}
		#algoritmo-Divide-vencerás.text-container p {
			flex-grow: 1;
		}
		#algoritmo-Backtraking .text-container {
		display: flex;
		}
		#algoritmo-Backtraking.text-container p {
			flex-grow: 1;
		}
		#Programación-dinámica .text-container {
		display: flex;
		}
		#Programación-dinámica.text-container p {
			flex-grow: 1;
		}
		#inicio .text-container {
		display: flex;
		}
		#inicio.text-container p {
			flex-grow: 1;
		}
		img {
			max-width: 100%;
			height: auto;
    }
	</style>
	<script>
		// Función para mostrar el div de información correspondiente
		function mostrarInfo(infoID) {
			// Ocultar todos los divs de información
			var infos = document.getElementsByClassName("info");
			for (var i = 0; i < infos.length; i++) {
				infos[i].style.display = "none";
			}

			// Mostrar el div de información correspondiente
			document.getElementById(infoID).style.display = "block";
		}

		// Mostrar el div de información del inicio cuando la página se carga
		window.onload = function() {
			mostrarInfo("inicio");
		}
	</script>
        <meta charset = "urf-8"> 
        <link rel="stylesheet" href="https://necolas.github.io/normalize.css/8.0.1/normalize.css">
		<link rel="stylesheet"  href="estilos.css">
		<link rel="shortcut icon" href="./image/1081009.png" type="image/x-icon">
</head>
<body style="background-color: #f2f2f2;">
	<!-- Header -->
	<header>
		<h1 style="text-align: center;">Algoritmos Voraces</h1>
	</header>

	<!-- Navigation bar -->
	<nav style="background-color: #282c34;">
		<a href="#" onclick="mostrarInfo('inicio')">Inicio</a>
		<a href="#" onclick="mostrarInfo('algoritmos-dijkstra')">Dijkstra</a>
		<a href="#" onclick="mostrarInfo('Floyd-Warshall')">Floyd-Warshall</a>
		<a href="#" onclick="mostrarInfo('algoritmos-prim')">Prim</a>
		<a href="#" onclick="mostrarInfo('algoritmos-kruskal')">Kruskal</a>
		<a href="#" onclick="mostrarInfo('algoritmo-de-fuerza-bruta')">Fuerza Bruta</a>
		<a href="#" onclick="mostrarInfo('algoritmo-Divide-vencerás')">Divide y venceras</a>
		<a href="#" onclick="mostrarInfo('algoritmo-Backtraking')">Backtraking</a>
		<a href="#" onclick="mostrarInfo('Programación-dinámica')">Programación dinámica</a>
	</nav>

	<!-- Contenido de la página web -->
	<div id="inicio" class="info" style="background-color: #d4f0fc" >
		<h1 style="text-align: center;">¿Que es un algoritmo voraz?</h1>
		<div style="margin-left: 25%;margin-left: 25%">
			<div class="text-container">
				<ul style="margin-top: 90px;">backtracking (o vuelta atrás) es una técnica algorítmica para encontrar soluciones a problemas que tienen una solución completa, en los que el orden de los elementos no importa, y en los que existen una serie de variables, a cada una de las cuales, debemos asignarle un valor teniendo en cuenta unas restricciones dadas.
					O lo que es lo mismo, es una estrategia algorítmica que busca todas las posibles soluciones dado un conjunto de variables inicial para encontrar el resultado definido por el problema. </ul>		
					<div class=" right-image" style="margin-right:600px;margin-left:50px ;">
						<img src="./image/images.png"  alt="Algoritmo de ataques de fuerza bruta">
					</div>
				</div>
				<div>
					<dt style="font-size: 20px;margin-top: 80px;">características de los algoritmos Voraces </dt>
				</div>
				<div style="margin-right:600px;margin-top: 20PX;">
					Se utilizan generalmente para resolver problemas de optimización (obtener el máximo o el mínimo). Toman decisiones en función de la información que está disponible en cada momento. Una vez tomada la decisión, ésta no vuelve a replantearse en el futuro. Suelen ser rápidos y fáciles de implementar. No siempre garantizan alcanzar la solución óptima.
					El enfoque “greedy” no nos garantiza obtener soluciones óptimas. Por lo tanto, siempre habrá que estudiar la corrección del algoritmo para demostrar si las soluciones obtenidas son óptimas o no.
				</div>
				<div>
					<dt style="font-size: 20px;margin-top: 40px;">En la tabla que veran a continuación colocaremos las ventajas y las desventajas de los algoritmos Voraces</dt>
				</div>
				<div style="margin-top: 5px;margin-right: 500px;">
					<table>
						<tr>
							<th>Ventajas</th>
							<th>Desventajas</th>
						</tr>
						<tr>
							<td>Son fáciles de entender y de implementar.</td>
							<td>No siempre encuentran la solución óptima.</td>
						</tr>
						<tr>
							<td>Tienen una complejidad temporal eficiente.</td>
							<td>Pueden llevar a soluciones subóptimas</td>
						</tr>
						<tr>
							<td>En general, requieren menos recursos.</td>
							<td>No siempre están disponibles para todos los problemas.</td>
						</tr>
						<tr>
							<td>Son útiles para resolver algunos problemas NP.</td>
							<td>Requieren que el problema tenga ciertas propiedades clave.</td>
						</tr>
					</table>
				</div>
				<div style="margin-top: 30px;">
					<dl>
						<dt style="font-size: 40px;">sobre nosotros</dt>
						<dt>pagina realizada por:</dt> 
						<dt>Aldo Daniel Reyes Carrillo</dt>
						<dt>Jaqueline Guadalupe Simon Gaspar</dt>
						<dt>Oscar Martinez Gonzale</dt>
					</dl>
				</div>
				<div style="margin-top: 30px;">
					<p style="font-size: 40px;">Bibliografia</p>
					<li style="margin-top: 10px;">
						<a href="https://es.wikipedia.org/wiki/Algoritmo_voraz" target="_blank">Algoritmos Voraces</a>
					</li>
					<li style="margin-top: 10px;">
						<a href="https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm-data-structure-and-algorithm-tutorials/" target="_blank">Divide y venceras</a>
					</li>
					<li style="margin-top: 10px;">
						<a href="https://brilliant.org/wiki/floyd-warshall-algorithm/" target="_blank">Floyd-Warshall</a>
					</li>
					<li style="margin-top: 10px;">
						<a href="https://www.programiz.com/dsa/floyd-warshall-algorithm" target="_blank">Floyd-Warshall</a>
					</li>
					<li style="margin-top: 10px;">
						<a href="https://sites.google.com/site/complejidadalgoritmicaes/prim" target="_blank">Prim</a>
					</li>
					<li style="margin-top: 10px;">
						<a href="https://sites.google.com/site/complejidadalgoritmicaes/kruskal" target="_blank">Kruskal</a>
					</li>
					<li style="margin-top: 10px;">
						<a href="https://sites.google.com/site/programacioniiuno/temario/unidad-6---anlisis-de-algoritmos/algoritmo-quicksort" target="_blank">Quicksort</a>
					</li>
					<li style="margin-top: 10px;">
						<a href="https://docs.jjpeleato.com/algoritmia/backtracking" target="_blank">Backtracking</a>
					</li>
					<li style="margin-top: 10px;">
						<a href="https://runestone.academy/ns/books/published/pythoned/Recursion/ProgramacionDinamica.html#:~:text=La%20programación%20dinámica%20es%20una,el%20menor%20número%20de%20monedas." target="_blank">Programación-dinámica</a>
					</li>
					<li style="margin-top: 10px;">
						<a href="https://keepcoding.io/blog/como-hacer-un-ciberataque-de-fuerza-bruta/#:~:text=Un%20ataque%20de%20fuerza%20bruta%20consiste%20en%20adivinar%20la%20contraseña,proviene%20de%20un%20host%20diferente." target="_blank">Fuerza-Bruta</a>
					</li>
				</div>
		</div>
    </div>
	<!-- inicio del div de dijsktra-->
	<div id="algoritmos-dijkstra" class="info" style="background-color: #d4f0fc">
		<h1 style="text-align: center;">Algoritmos dijkstra</h1>
		<div style="margin-left: 250px;margin-left: 250px;">
			<div class="text-container">
				<p  style="margin-top: 90px;">El algoritmo de Dijkstra, también llamado algoritmo de caminos mínimos, es un algoritmo para la determinación del camino más corto dado un vértice origen al resto de los vértices en un grafo con pesos en cada arista.</p>
		<div class=" right-image" style="margin-right:600px;margin-left:50px ;">
			<img src="./image/dijkstra.png"  width="250"alt="Algoritmo de Dijkstra">
		</div>
		</div>
		<div>
			<dt style="font-size: 20px;margin-top: 80px;">En la tabla que veran a continuación colocaremos las ventajas y las desventajas del  algoritmo de dijsktra </dt>
		</div>
		<div>
			<dt style="margin-right: 500px;">
				<table style="margin-top: 20px;">
				<tr >
					<th>Ventajas</th>
					<th>Desventajas</th>
				</tr>
				<tr>
					<td>1.-Eficiencia: el algoritmo de Dijkstra tiene una complejidad de tiempo de O(V^2), donde V es el número de nodos en el grafo. Para grafos más grandes, se pueden utilizar implementaciones más eficientes, como Dijkstra con cola de prioridad que tiene una complejidad de tiempo de O((E+V) log V). En cualquier caso, el algoritmo de Dijkstra es uno de los algoritmos más eficientes para encontrar el camino más corto en un grafo.</td>
					<td>Restricción de pesos no negativos: el algoritmo de Dijkstra solo funciona correctamente en grafos con pesos no negativos. Si hay aristas con pesos negativos, se deben usar otros algoritmos, como Bellman-Ford, que pueden manejar estos casos.</td>
				</tr>
				<tr>
					<td>2.-Generalidad: el algoritmo de Dijkstra se puede aplicar a cualquier grafo ponderado con pesos no negativos, lo que lo hace útil para una amplia variedad de problemas en diferentes áreas.</td>
					<td>Complejidad de memoria: el algoritmo de Dijkstra requiere mantener un registro de los nodos visitados y sus distancias, lo que puede requerir mucho espacio de memoria en grafos grandes.</td>
				</tr>
				<tr>
					<td>3.-Precisión: el algoritmo de Dijkstra siempre encuentra el camino más corto en un grafo ponderado con pesos no negativos, lo que lo hace útil en situaciones en las que se requiere precisión en las soluciones.</td>
					<td>Requiere un nodo de origen: el algoritmo de Dijkstra requiere un nodo de origen para comenzar la búsqueda del camino más corto. Si no se especifica un nodo de origen, se debe usar otro algoritmo, como Floyd-Warshall, que puede encontrar el camino más corto entre todos los pares de nodos.</td>
				</tr>
				<tr>
					<td>4-.-Versatilidad: el algoritmo de Dijkstra se puede modificar para encontrar todos los caminos más cortos desde un nodo de origen a todos los demás nodos en un grafo, lo que lo hace útil para problemas de análisis de redes.</td>
					<td> No garantiza el camino más corto en grafos con pesos negativos: si hay ciclos negativos en el grafo, el algoritmo de Dijkstra no funciona correctamente y puede dar resultados erróneos. </td>
				</tr>
				</table>
			</dt>
			<div style="margin-top: 30px;font-size: 20px;font-weight: 700 px;">
				Pasos a seguir del algoritmo dijkstra
			</div>
			<dt style="margin-top: 20px;">
				Para comprender el Algoritmo de Dijkstra, tomemos un gráfico y encontremos el camino más corto desde el origen hasta todos los nodos.
				Considere el siguiente gráfico y src = 0
			</dt>
			<img src="./image/ejemploD.jpg" width="400" alt="200px" style="margin-top: 20px;">
			<dt style="text-align:left ;">
				<ul>
					Paso 1:
					<li >
					El conjunto sptSet inicialmente está vacío y las distancias asignadas a los vértices son {0, INF, INF, INF, INF, INF, INF, INF} donde INF indica infinito.  
					</li>
					<li>
						Ahora elija el vértice con un valor de distancia mínimo. Se selecciona el vértice 0, inclúyalo en sptSet .
						<p style="margin-top: 0;"> Entonces sptSet se convierte en {0}. Después de incluir 0 en sptSet , actualice los valores de distancia de sus vértices adyacentes.</p>
					</li>
					<li style="margin-top:0px;">
						Los vértices adyacentes de 0 son 1 y 7. Los valores de distancia de 1 y 7 se actualizan como 4 y 8. 
					</li>
				</ul>
				<div> 
				El siguiente subgráfico muestra los vértices y sus valores de distancia, solo se muestran los vértices con valores de distancia finitos. Los vértices incluidos en SPT se muestran en color verde .
				</div>
			</dt>
			<img src="./image/empl2.jpg" alt="250px" style="margin-top: 20px;margin-left:200px;" width="90">
			<dt>
				<ul>
					Paso 2:
					<li>
						Elija el vértice con un valor de distancia mínimo y que no esté incluido en SPT (no en sptSET). El vértice 1 se selecciona y se agrega a sptSet. 
					</li>
					<li>
						Entonces sptSet ahora se convierte en {0, 1}. Actualice los valores de distancia de los vértices adyacentes de 1.
					</li>
					<li>
						El valor de la distancia del vértice 2 se convierte en 12 .
					</li>
				</ul>
			</dt>
			<img src="./image/DIJ2.jpg" alt="300px" style="margin-top: 20px;margin-left: 200px;">
			<dt>
				<ul>
					Paso 3:
					<li>
						Elija el vértice con un valor de distancia mínimo y que no esté incluido en SPT (no en sptSET). Se selecciona el vértice 7. Entonces sptSet ahora se convierte en {0, 1, 7}. 
					</li>
					<li>
						Actualice los valores de distancia de los vértices adyacentes de 7. El valor de distancia de los vértices 6 y 8 se vuelve finito ( 15 y 9 respectivamente). 
					</li>
				</ul>
			</dt>
			<img src="./image/DIJ3.jpg" alt="400px" style="margin-top: 20px;margin-left: 200px;">
			<dt>
				<ul>
					Paso 4:
					<li>
						Elija el vértice con un valor de distancia mínimo y que no esté incluido en SPT (no en sptSET). Se elige el vértice 6. Entonces sptSet ahora se convierte en {0, 1, 7, 6} .  
					</li>
					<li>
						Actualice los valores de distancia de los vértices adyacentes de 6. Se actualizan los valores de distancia de los vértices 5 y 8.
					</li>
				</ul>
				<img src="./image/DIJ4.jpg" alt="400px" style="margin-top: 20px;margin-left: 200px;">
				<div style="margin-top: 20px;">
					Repetimos los pasos anteriores hasta que sptSet incluya todos los vértices del gráfico dado. Finalmente, obtenemos el siguiente árbol de ruta más corta (SPT).
				</div>
				<img src="./image/DIJ5.jpg" alt="500px" style="margin-top: 20px;margin-left: 200px;">
                <div style="margin-top: 30px;">
                <p> Aqui un pequeño video  que habla sobre el  algoritmo de dijsktra</p>
                <video width="640" height="360" controls style="margin-top: 20px;">
                <source src="./image/IO Tutoriales - 02 Algoritmo de DIJKSTRA.mp4" type="video/mp4">
                Tu navegador no soporta la etiqueta de video.
                </video>
				</div>
			
		</div>
			</div>
	</div>
	<!-- Fin de div de dijsktra-->
	
	<!-- inicio del div de floyd-->
	<div id="Floyd-Warshall" class="info" style="background-color: #d4f0fc ;">
		<h1 style="text-align: center;">Algoritmo Floyd-Warshall</h1>
		<div style="margin-left: 250px;margin-left: 250px;">
		<div class="text-container">
			<p  style="margin-top: 90px;">El algoritmo de Floyd-Warshall es un algoritmo de ruta más corta para gráficos . Al igual que el algoritmo de Bellman-Ford o el algoritmo de Dijkstra , calcula el camino más corto en un gráfico. Sin embargo, Bellman-Ford y Dijkstra son algoritmos de fuente única y ruta más corta. Esto significa que solo calculan la ruta más corta desde una sola fuente. Floyd-Warshall, por otro lado, calcula las distancias más cortas entre cada par de vértices en el gráfico de entrada.</p>
	<div class=" right-image" style="margin-right:600px;margin-left:50px ;">
		<img src="./image/Floyd-Warshall-Algorithm.png"  width="250"alt="Algoritmo de Dijkstra">
	</div>
		</div>
		<div>
			<dt style="font-size: 20px;margin-top: 80px;">En la tabla que veran a continuación colocaremos las ventajas y las desventajas del  algoritmo Floyd-Warshall </dt>
		</div>		
		<div style="margin-top: 20px;margin-right: 500px;">
			<table >
				<tr >
					<th>Ventajas</th>
					<th>Desventajas</th>
				</tr>
				<tr>
					<td>Encuentra la ruta más corta entre todos los pares de nodos en un grafo ponderado con peso negativo.</td>
					<td>Tiene complejidad de tiempo de O(V^3), lo que puede ser ineficiente para grafos grandes.</td>
				</tr>
				<tr>
					<td>Funciona para grafos con pesos no negativos o negativos.</td>
					<td>Requiere una gran cantidad de memoria para almacenar la tabla de distancias de todos los pares.</td>
				</tr>
				<tr>
					<td>Es un algoritmo de programación dinámica, lo que significa que encuentra la solución óptima al subproblema y la combina para obtener la solución óptima al problema general.</td>
					<td>No funciona para grafos con ciclos negativos alcanzables desde el nodo origen.</td>
				</tr>
				<tr>
					<td>Funciona para grafos no dirigidos y dirigidos.</td>
					<td>No es útil para encontrar la ruta más corta entre dos nodos en particular.</td>
				</tr>
			</table>
		</div>
		<div style="margin-right:500px ;">
			<div style="margin-top: 30px;font-size: 20px;font-weight: 700 px;">
				Pasos a seguir del algoritmo   
			</div>
			<div style="margin-top: 10px;">
				<p>Tomaremos la siguiente imagen para expliacar los pasos a seguir</p>
				<img src="./image/fw.jpg" alt="200 px" style="margin-top: 5px;">
			</div>
			<dt style="margin-top: 10px">
				<ul>Sigue los pasos a continuación para encontrar el camino más corto entre todos los pares de vértices.</ul>
				<div style="font-size: 20px;font-weight: 700 px;">Paso 1</div>
				<li>
					Crea una matriz de dimensión donde n es el número de vértices. La fila y la columna se indexan como A<sup>0</sup> n*n i y j respectivamente.i y j son los vértices de la gráfica.
					cada celda A[i] [j] se llena con la distancia de vértice a vértice. Si no hay camino de vértice a vértice, la celda se deja como infinita.
				</li>
				<figure>
					<img src="./image/martiz.jpg" alt="100 px" width="400" style="margin-top:10px;">
					<figcaption>Rellene cada celda con la distancia entre el i-ésimo y el j-ésimo vértice</figcaption>
				</figure>
				<div style="font-size: 20px;font-weight: 700 px;">Paso 2</div>
				<li>
					Ahora, crea una matriz usando matrix. Los elementos de la primera columna y la primera fila se dejan como están. Las celdas restantes se llenan de la siguiente manera. Dejar A<sup>1</sup> A<sup>0</sup>
					<div style="margin-top: 10px"> k ser el vértice intermedio en el camino más corto desde el origen hasta el destino. En este paso,k es el primer vértice. A[i][j]está lleno de (A[i][k] + A[k][j]) if (A[i][j] > A[i][k] + A[k][j]).</div>
					<div style="margin-top: 10px;">Es decir, si la distancia directa desde el origen hasta el destino es mayor que el camino a través del vértice k, entonces la celda se llena con A [i] [k] + A [k] [j].</div>
					<div style="margin-top: 10px;">En este paso, k es el vértice 1. Calculamos la distancia desde el vértice de origen hasta el vértice de destino a través de este vértice k.</div>
					<div> <img src="./image/fw-Matrix-2.jpg" alt="50 px" width="600" style="margin-top: 20px;">
						<figcaption>Calcule la distancia desde el vértice de origen hasta el vértice de destino a través de este vértice k</figcaption>
					</div>
					<DIV style="margin-top: 10px;">Por ejemplo: Para , la distancia directa del vértice 2 al 4 es 4 y la suma de la distancia del vértice 2 al 4 a través del vértice (es decir, del vértice 2 al 1 y del vértice 1 al 4) es 7. Dado que , se llena con 4 A <sup>1</sup>[2, 4]4 < 7A<sup>0</sup>[2, 4]</DIV>
				</li>
				<div style="font-size: 20px;font-weight: 700 px;margin-top: 12px;">Paso 3</div>
				<li style="margin-top:  10px;">
					Del mismo modo, se crea utilizando . Los elementos de la segunda columna y la segunda fila se dejan como están. En este paso,A<sup>2</sup> A<sup>1</sup> 
					<p>k es el segundo vértice (es decir, el vértice 2). Los pasos restantes son los mismos que en el paso 2 .</p>
					<div><img src="./image/fw-Matrix-3.jpg" alt="100" width="600"  style="margin-top: 20px;">
						<figcaption>Calcule la distancia desde el vértice de origen hasta el vértice de destino a través de este vértice 2</figcaption>
					</div>
				</li>
				<div style="font-size: 20px;font-weight: 700 px;margin-top: 12px;">Paso 4</div>
				<li style="margin-top: 10px;">
					Del mismo modo, y también se crea. A<sup>3</sup>A<sup> 4</sup>
					<p> <img src="./image/fw-Matrix-4.jpg" alt="100" width="600" style="margin-top: 12px;">
						<figcaption>Calcule la distancia desde el vértice de origen hasta el vértice de destino a través de este vértice 3</figcaption>
					</p>
				</li>
				<p><img src="./image/fw-Matrix-5.jpg" alt="100" width="600" style="margin-top: 30px;">
				<figcaption>Calcule la distancia desde el vértice de origen hasta el vértice de destino a través de este vértice 4</figcaption>
				</p>
				<div style="font-size: 20px;font-weight: 700 px;margin-top: 12px;">Paso 5</div>
				<li style="margin-top: 10px;">
					A<sup>4</sup> da el camino más corto entre cada par de vértices.
				</li>
				<div style="margin-top: 30px;">
					<p style="font-size: 30px;">Aqui un pequeño ejemplo del algoritmo Floyd-Warshall</p>
					<video width="640" height="360" controls style="margin-top: 20px;">
						<source src="./image/algoritmo de Floyd-Warshall.mp4" type="video/mp4">
						Tu navegador no soporta la etiqueta de video.
					</video>
				</div>
			</dt>
		</div>
	</div>
	</div>
		<!-- Fin de div de Floyd-Warshall-->

		<!--inicio de div de prim-->
	<div id="algoritmos-prim" class="info" style="background-color: #d4f0fc">
		<h1 style="text-align: center;">Algoritmos Prim</h1>
		<div style="margin-left: 250px;margin-left: 250px;">
			<div class="text-container">
				<p  style="margin-top: 90px;">El algoritmo de Prim, dado un grafo conexo, no dirigido y ponderado, encuentra un árbol de expansión mínima. Es decir, es capaz de encontrar un subconjunto de las aristas que formen un árbol que incluya todos los vértices del grafo inicial, donde el peso total de las aristas del árbol es el mínimo posible.</p>
		<div class=" right-image" style="margin-right:600px;margin-left:50px ;">
			<img src="./image/7.png"  width="250"alt="Algoritmo de Prim">
		</div>
			</div>
		<div>
			<dt style="font-size: 20px;margin-top: 80px;">En la tabla que veran a continuación colocaremos las ventajas y las desventajas del  algoritmo de Prim </dt>
		</div>
		<div  style="margin-top: 20px;margin-right: 500px;">
			<table>
				<tr >
					<th>Ventajas</th>
					<th>Desventajas</th>
				</tr>
				<tr>
					<td>Es un algoritmo de aprendizaje supervisado eficiente</td>
					<td>Sólo es adecuado para problemas de clasificación binaria</td>
				</tr>
				<tr>
					<td>Produce modelos simples y fácilmente interpretables</td>
					<td>Requiere una gran cantidad de datos para el entrenamiento</td>
				</tr>
				<tr>
					<td>Puede manejar datos con alta dimensionalidad</td>
					<td>Puede tener dificultades con datos que tienen ruido o errores</td>
				</tr>
				<tr>
					<td>Puede ser utilizado para la selección de características</td>
					<td>Puede no ser el mejor algoritmo para problemas de clasificación</td>
				</tr>
			</table>
		</div>
			<div style="margin-right:500px;margin-top: 20PX;">
				<ul style="font-size: 20px;"> Funcionamiento del algoritmo de Prim</ul>
				<li>Se marca un vértice cualquiera. Será el vértice de partida.</li>
				<li>Se selecciona la arista de menor peso incidente en el vértice seleccionado anteriormente y se selecciona el otro vértice en el que incide dicha arista.</li>
				<li>Repetir el paso 2 siempre que la arista elegida enlace un vértice seleccionado y otro que no lo esté. Es decir, siempre que la arista elegida no cree ningún ciclo.</li>
				<li>El árbol de expansión mínima será encontrado cuando hayan sido seleccionados todos los vértices del grafo.</li>
				<ul style="font-size: 20px;" > Los pasos a seguir serian los siguientes</ul>
					<li>	
						Este es el grafo inicial. Los números indican el peso de las aristas. Se elige de manera aleatoria uno de los vértices que será el vértice de partida. En este caso se ha elegido el vértice D.
					</li>
					<img src="./image/1.png"  width="250"alt="Algoritmo de Prim" style="margin-top: 20PX;margin-left: 200px;">
					<li>		
					Se selecciona la arista de menor peso de entre todas las incidentes en el vértice D, siempre que la arista seleccionada no cree ningún ciclo. En este caso es la arista AD.
					</li>
					<img src="./image/2.png" width="250" style="margin-top: 20PX;margin-left: 200px;">
					<li>
						Ahora se selecciona la arista de menor peso de entre todas las incidentes en los vértices D y A, siempre que la arista seleccionada no cree ningún ciclo. En este caso es la arista DF.
					</li>
					<img src="./image/3.png" width="250" style="margin-top: 20px;margin-left: 200px; ">
					<li>
						Se selecciona la arista de menor peso de entre todas las incidentes en los vértices D, A y F, siempre que la arista seleccionada no cree ningún ciclo. En este caso es la arista AB. Llegado a este punto, la arista DB no podrá ser seleccionada, ya que formaría el ciclo ABD.
					</li>
					<img src="./image/4.png" width="250" style="margin-top: 20px;margin-left: 200px; ">
					<li>
						Se selecciona la arista de menor peso de entre todas las incidentes en los vértices D, A, F y B, siempre que la arista seleccionada no cree ningún ciclo. En este caso es la arista BE. Llegado a este punto, las aristas DE y EF no podrán ser seleccionadas, ya que formarían los ciclos ABED y ABEFD respectivamente.
					</li>
					<img src="./image/5.png" width="250" style="margin-top: 20px;margin-left: 200px; ">
					<li>
						Se selecciona la arista de menor peso de entre todas las incidentes en los vértices D, A, F, B y E, siempre que la arista seleccionada no cree ningún ciclo. En este caso es la arista EC. Llegado a este punto, la arista BC no podrá ser seleccionada, ya que formaría el ciclo BEC.
					</li>
					<img src="./image/6.png" width="250" style="margin-top: 20px;margin-left: 200px; ">
					<li>
						Solo que disponible el vértice G, por lo tanto se selecciona la arista de menor peso que incide en dicho vértice. Es la arista EG. Como todos los vértices ya han sido seleccionados el proceso ha terminado. Se ha obtenido el árbol de expansión mínima con un peso de 39.
					</li>
					<img src="./image/8.png-removebg-preview.png" width="250" style="margin-top: 20px;margin-left: 200px; ">
			</div>
			<div style="margin-top: 30px;">
				<p style="font-size: 30px;">Aqui un pequeño ejemplo del algoritmo de Prim</p>
				<video width="640" height="360" controls style="margin-top: 10px;">
					<source src="./image/Algoritmo de Prim.mp4" type="video/mp4">
					Tu navegador no soporta la etiqueta de video.
				</video>
			</div>
		</div>	
	</div>
			<!-- Fin de div de Prim-->

			<!-- inicio de div de kruskal-->
			<div id="algoritmos-kruskal" class="info"  style="background-color: #d4f0fc">
				<h1 style="text-align: center;">Algoritmos Kruskal</h1>
				<div style="margin-left: 250px;margin-left: 250px">
					<div class="text-container">
						<p  style="margin-top: 90px;">El algoritmo de Prim, dado un grafo conexo, no dirigido y ponderado, encuentra un árbol de expansión mínima. Es decir, es capaz de encontrar un subconjunto de las aristas que formen un árbol que incluya todos los vértices del grafo inicial, donde el peso total de las aristas del árbol es el mínimo posible.</p>
				<div class=" right-image" style="margin-right:600px;margin-left:50px ;">
					<img src="./image/7.png"  width="250"alt="Algoritmo de Prim">
				</div>
					</div>
					<div>
						<dt style="font-size: 20px;margin-top: 80px;">En la tabla que veran a continuación colocaremos las ventajas y las desventajas del  algoritmo kruskal </dt>
					</div>
					<div style="margin-top: 20px;margin-right: 500px;">
						<table>
							<tr>
								<th>Ventajas</th>
								<th>Desventajas</th>
							</tr>
							<tr>
								<td>Es un algoritmo simple y fácil de implementar.</td>
								<td>Puede ser menos eficiente que otros algoritmos en grafos densos.</td>
							</tr>
							<tr>
								<td>Produce un árbol de expansión mínima (MST) garantizado para grafos ponderados sin ciclo.</td>
								<td>Puede ser menos adecuado para grafos con pesos negativos, ya que puede generar un MST incorrecto en ese caso.</td>
							</tr>
							<tr>
								<td>Es un algoritmo voraz (greedy), lo que significa que toma decisiones óptimas en cada paso para lograr el resultado final óptimo.</td>
								<td>Puede generar árboles de expansión mínima no únicos en algunos casos, lo que puede requerir una solución adicional para seleccionar el MST óptimo.</td>					
							</tr>
							<tr>
								<td>Tiene una complejidad de tiempo de O(E log E), donde E es el número de aristas del grafo, lo que lo hace eficiente para grafos dispersos.</td>
								<td>Puede ser difícil de implementar correctamente en algunos casos, especialmente en grafos grandes y complejos</td>
							</tr>
							<tr>
								<td>Es adecuado para aplicaciones en las que se requiere una red de comunicación eficiente, como en la planificación de redes de transporte o la optimización de rutas de entrega.</td>
								<td>Puede ser menos adecuado para aplicaciones en las que se requiere una estructura jerárquica explícita, ya que los árboles de expansión mínima no tienen una raíz específica.</td>
							</tr>
						</table>
					</div>
					<div style="margin-right:500px;margin-top: 20PX;">
						<ul>Funcionamiento del algoritmo kruskal</ul>
						<li>Se selecciona, de entre todas las aristas restantes, la de menor peso siempre que no cree ningún ciclo.</li>
						<li>Se repite el paso 1 hasta que se hayan seleccionado |V| - 1 aristas.</li>
						<p>  Siendo V el número de vértices.</p>
						<ul style="font-size: 20px;" > Los pasos a seguir serian los siguientes</ul>
						<li>
							Este es el grafo inicial. Los números indican el peso de las aristas. Se elige de manera aleatoria uno de los vértices que será el vértice de partida. N este caso se ha elegido el vértice D.
						</li>
						<img src="./image/11.png" width="250" style="margin-top: 20px;margin-left: 200px;">
						<li>
							Se selecciona, de entre todas las aristas restantes, la de menor siempre que no cree ningún ciclo. Las aristas de menor peso son las aristas AD y CE (5). Se ha seleccionado de manera aleatoria la arista AD.
						</li>
						<img src="./image/12.png" width="250" style="margin-top: 20px;margin-left: 200px">
						<li>
							Se selecciona, de entre todas las aristas restantes, la de menor siempre que no cree ningún ciclo. Ésta es la arista CE.
						</li>
						<img src="./image/13.png" width="250" style="margin-top: 20px;margin-left: 200px;">
						<li>
							Seleccionamos DF, con peso 6, que es la siguiente arista de menor peso que no forma ciclos.
						</li>
						<img src="./image/14.png" width="250" style="margin-top: 20px;margin-left: 200px">
						<li>
							De las aristas restantes, las de menor peso son las aristas AB y BE, de peso 7. AB se elige aleatoriamente, y se añade al conjunto de las aristas seleccionadas. De este modo, la arista DB no puede ser seleccionada ya que formaría el ciclo ADB. Por tanto la marcamos en rojo.
						</li>
						<img src="./image/15.png" width="250" style="margin-top: 20px;margin-left: 200px;">
						<li>
							Siguiendo el proceso seleccionamos la arista BE con peso 7. Además marcamos en rojo las aristas BC, DE y FE ya que formarían los ciclos BCE, DEBA, FEBAD respectivamente.
						</li>
						<img src="./image/16.png" width="250" style="margin-top: 20px;margin-left: 200px;">
						<li>
							Por último se selecciona la arista EG de peso 9. Como han sido seleccionadas un número de aristas igual al número de vértices menos uno, el proceso ha terminado. Se ha obtenido el árbol de expansión mínima con un peso de 39.
						</li>
						<img src="./image/17.png" width="250" style="margin-top: 20px;margin-left: 200px;">
					</div>
					<div style="margin-top: 30px;">
						<p style="font-size: 30px;">Aqui un pequeño ejemplo del algoritmo de Prim</p>
						<video width="640" height="360" controls style="margin-top: 10px;">
							<source src="./image/Algoritmo de Kruskal.mp4" type="video/mp4">
							Tu navegador no soporta la etiqueta de video.
						</video>
					</div>
				</div>
			</div>
			<!--fin de div de kruskal-->

			<!--inicio div de fuerza bruta-->
			<div id="algoritmo-de-fuerza-bruta" class="info" style="background-color: #d4f0fc;">
				<h1 style="text-align:center;">Algoritmos de fuerza bruta</h1>
				<div style="margin-left: 250px;margin-left: 250px">
					<div class="text-container">
						<p  style="margin-top: 90px;">Un ataque de fuerza bruta consiste en adivinar la contraseña y/o el nombre de usuario de una persona por medio de la automatización de pruebas de ensayo y error. Algunas herramientas permiten realizar estas pruebas y simular que cada una de ellas proviene de un host diferente. </p>
				<div class=" right-image" style="margin-right:600px;margin-left:50px ;">
					<img src="./image/que-es-ataque-fuerza-bruta.jpg"  width="250"alt="Algoritmo de ataques de fuerza bruta">
				</div>
					</div>
				<div>
					<dt style="font-size: 20px;margin-top: 80px;">En la tabla que veran a continuación colocaremos las ventajas y las desventajas de los algoritmos de ataque de fuerza bruta.</dt>
				</div>
				<div  style="margin-top: 20px;margin-right: 500px;">
					<table>
					<tr>
						<th>Ventajas</th>
						<th>Desventajas</th>
					</tr>
					<tr>
						<td>Pueden ser efectivos en el descifrado de contraseñas y credenciales débiles.</td>
						<td>Pueden ser ineficientes y requieren mucho tiempo y recursos para ejecutarse.</td>
					</tr>
					<tr>
						<td>Son relativamente simples de implementar y no requieren conocimientos especializados.</td>
						<td>Pueden ser detectados y bloqueados fácilmente por sistemas de seguridad modernos.</td>
					</tr>
					<tr>
						<td>Son útiles para demostrar vulnerabilidades de seguridad y resaltar la importancia de tener contraseñas fuertes y políticas de seguridad adecuadas.</td>
						<td>Son ilegales y pueden llevar a consecuencias legales graves, incluyendo multas y sentencias de prisión.</td>
					</tr>
					<tr>
						<td>Son una buena opción si no hay otra forma de acceder a un sistema protegido o si se necesita acceder rápidamente a un sistema durante una emergencia.</td>
						<td>No son efectivos contra contraseñas complejas y aleatorias generadas por computadora.</td>
					</tr>
					<tr>
						<td>Pueden ser útiles para fines educativos y de investigación en ciberseguridad.</td>
						<td>Pueden causar daños irreparables a los sistemas, especialmente si se utilizan con fines maliciosos.</td>
					</tr>
					</table>
				</div>
				<div style="margin-right:500px;margin-top: 20PX;">
					<p style="font-size: 20px;">A continuación les mostrare un pequeño ejemplo de como seria un ataque de fuerza bruta</p>
					<div style="font-size: 18PX;">
					<ul>Para aprender cómo hacer un ciberataque de fuerza bruta, te explicaremos el paso a paso para llevar a cabo un ejercicio de laboratorio y observar cómo funciona.
						<li>Crea dos máquinas virtuales. Una de ellas, con el sistema operativo para pentesters, Kali Linux; la otra, con un sistema operativo Windows 7 (la versión más antigua posible). También puedes optar por una máquina virtual desarrollada intencionalmente con vulnerabilidades, como Metasploitable 1, 2 o 3.</li>
						<li>Crea dos diccionarios: uno para usuarios y otro para contraseñas. Los puedes descargar en internet o construirlos tú mismo por medio de generadores de diccionarios de contraseñas.</li>
						<li>Abre Hydra en tu máquina con Kali Linux, por medio del comando «xhydra», que puedes ejecutar en una terminal del sistema.</li>
						<li>Al ejecutar el comando «xhydra», se abrirá la interfaz gráfica de Hydra, el programa estándar para hacer ataques de fuerza bruta en auditorías de seguridad.</li>
						<ul>Para usar Hydra y entender cómo hacer un ciberataque de fuerza bruta debes:
							<li>Establecer la dirección IP de tu máquina Windows 7 o Metasploitable. Para conocer la dirección IP de tus máquinas, ejecuta el comando «ipconfig» desde sus consolas.</li>
							<li>Ahora, escoge el puerto donde se encuentre el servicio que deseas poner a prueba. Por ejemplo, si quieres dirigir el ataque al protocolo SSH, elige el puerto 22.</li>
							<li> Escoge el protocolo al que desees dirigir el ataque. Si has elegido el puerto 22, selecciona el protocolo correspondiente, que es el SSH.</li>
							<li>Habilita la opción SSL para que el sistema no detecte el ataque. </li>
							<li>Habilita la opción «Show attempts» si deseas ver los intentos hechos por el programa.</li>
							<li>Dirígete a la pestaña «Password«.</li>
							<li>Elige el archivo de texto con el diccionario de nombres de usuario en el campo «Username list«.</li>
							<li>Elige el archivo de texto con el diccionario de contraseñas en el campo «Password list«.</li>
							<li>En la opción «Tuning«, reduce el número de tareas «Number of tasks» a 5, para que el sistema soporte las peticiones.</li>
							<li>Finalmente, ejecuta el proceso con el botón «Start«.</li>
						</ul>
					</ul>
				</div>
				</div>
				<div style="margin-top: 30px;">
					<p style="font-size: 30px;">Aqui un pequeño ejemplo del algoritmo de Prim</p>
					<video width="640" height="360" controls style="margin-top: 10px;">
						<source src="./image/Algoritmo Fuerza Bruta.mp4" type="video/mp4">
						Tu navegador no soporta la etiqueta de video.
					</video>
				</div>
			</div>
			</div>
			<!--fin de div de fuerza bruta-->

			<!--incio de div de divide y venceras-->
		<div id="algoritmo-Divide-vencerás" class="info" style="background-color: #d4f0fc;">
			<h1 style="text-align: center;font-size: 20px;">Algoritmo divide y venceras</h1>
			<div  style="margin-left: 250px;margin-left: 250px">
				<div class="text-container">
					<ul style="margin-top: 90px;">Divide y vencerás es un paradigma algorítmico, similar a los paradigmas de programación Dinámica y Algoritmos ávidos o glotones. Un algoritmo Divide y Vencerás típico resuelve un problema siguiendo estos 3 pasos. </ul>		
			<div class=" right-image" style="margin-right:600px;margin-left:50px ;">
				<img src="./image/algo76.png"  width="300"alt="Algoritmo de ataques de fuerza bruta">
			</div>
				</div>
				<div style="margin-right: 400px;margin-top: 20px;">
					<li>Dividir: Descomponer el problema en sub-problemas del mismo tipo. Este paso involucra descomponer el problema original en pequeños sub-problemas. Cada sub-problema debe representar una parte del problema original. Por lo general, este paso emplea un enfoque recursivo para dividir el problema hasta que no es posible crear un sub-problema más.</li>
					<li> Vencer:  Resolver los sub-problemas recursivamente. Este paso recibe un gran conjunto de sub-problemas a ser resueltos. Generalmente a este nivel, los problemas se resuelven por sí solos.</li>
					<li> Combinar: Combinar las respuestas apropiadamente. Cuando los sub-problemas son resueltos, esta fase los combina recursivamente hasta que estos formulan la solución al problema original. Este enfoque algorítmico trabaja recursivamente y los pasos de conquista y fusión trabajan tan a la par que parece un sólo paso.</li>
				</div>
				<div>
					<dt style="font-size: 20px;margin-top: 30px;">En la tabla que veran a continuación colocaremos las ventajas y las desventajas de los algoritmos divide y vencerás</dt>
				</div>
				<div  style="margin-top: 20px;margin-right: 500px;">
					<table>
						<tr>
							<th>Ventajas</th>
							<th>Desventajas</th>
						</tr>
						<tr>
							<td>Permite resolver problemas grandes dividiéndolos en subproblemas más pequeños y manejables</td>
							<td>En algunos casos, puede no ser fácil identificar la mejor forma de dividir el problema</td>
						</tr>
						<tr>
							<td>Cada subproblema puede resolverse de manera independiente, lo que permite paralelizar la solución para acelerar el tiempo de cómputo</td>
							<td>En algunos casos, puede ser necesario combinar las soluciones de los subproblemas para obtener la solución del problema original</td>
						</tr>
						<tr>
							<td>En general, tiene una complejidad de tiempo de ejecución logarítmica o polinómica, lo que lo hace eficiente para resolver problemas grandes</td>
							<td>Para algunos problemas específicos, puede ser necesario un enfoque diferente para lograr la mejor eficiencia </td>
						</tr>
						<tr>
							<td>Es una técnica muy utilizada en algoritmos de búsqueda y ordenamiento de datos</td>
							<td>Puede ser difícil de aplicar a problemas que no se prestan fácilmente a la división en subproblemas más pequeños</td>
						</tr>
					</table>
					<div >
						<div style="margin-right:500px;margin-top: 20PX;">
							<p style="font-size: 20px;">A continuación les mostrare un pequeño ejemplo de como seria un algoritmo divide y venceras.</p>
						</div>
					</div>
					<div>
						<p>usaremos este conjunto de numeros como ejemplo del algoritmo Quicksort</p>
						<p style="background-color: aquamarine;margin-right:700px;font-size: 20px;">[ 42, 124, 23, 5, 89, -1, 44, 643, 34]</p>
						<p>En nuestro ejemplo vamos a seleccionar el primer elemento de la lista como el pivot.</p>
						<p>Veamos entonces, paso a paso se va a ir formando este árbol de llamados recursivos. En rojo mostramos el pivot. A izquierda las sublistas menores, y a la derecha la de los mayores.</p>
						<img src="./image/quick-removebg-preview.png "  width="400" style="margin-top: 20px;margin-left: 200px;" >
						<p>En verde están los nodos "caso base", es decir lista de un único elemento o bien lista vacía.</p>
						<p>Entonces estos nodos se van a resolver fácil y se van a concatenar con los pivots de arriba. Así empezamos a volver en los llamados recursivos.</p>
						<img src="./image/quick-removebg-preview (1).png"width="400" style="margin-top: 20px;margin-left: 200px;" >
						<p>Si sacamos las listas originales de cada nodo y solo dejamos los pivots, queda más claro:</p>
						<img src="./image/1aHvELQ8Erwn1db6H22l_Exaxn-CBowzE-removebg-preview.png" width="400" style="margin-top: 20px;margin-left: 200px;">
						<p>Ya tenemos todo el tercer nivel resuelto así que cada par va a retornar para concatenarse entre sí con el pivot en el medio.</p>
						<img src="./image/Captura_de_pantalla_2023-05-07_140000-removebg-preview.png" width="400" style="margin-top: 20px;margin-left: 200px;">
						<p>Ya casi estamos. Tenemos dos listas ordenadas, la de los menores y la de los mayores, y el primer pivot. Concatenamos y eso nos da el resultado final:</p>
						<img src="./image/1OBTahlHJEodxIiBixqAilacNP3h7lftd.png" width="400" style="margin-top: 20px;margin-left: 200px;">
					</div>
					<div style="margin-top: 30px;">
						<p style="font-size: 30px;">Aqui un pequeño ejemplo del algoritmo de Prim</p>
						<video width="640" height="360" controls style="margin-top: 10px;">
							<source src="./image/Divide y vencerás.mp4" type="video/mp4">
							Tu navegador no soporta la etiqueta de video.
						</video>
					</div>
			</div>
			</div>
		</div>
		<!--fin de div de divide y venceras-->
			<div id="algoritmo-Backtraking" class="info"style="background-color: #d4f0fc;">
		<h1 style="text-align: center;">Algoritmo Backtraking</h1>
		<div  style="margin-left: 250px;margin-left: 250px">
		<div class="text-container">
		<ul style="margin-top: 180px;">Backtracking (o vuelta atrás) es una técnica algorítmica para encontrar soluciones a problemas que tienen una solución completa, en los que el orden de los elementos no importa, y en los que existen una serie de variables, a cada una de las cuales, debemos asignarle un valor teniendo en cuenta unas restricciones dadas.
			O lo que es lo mismo, es una estrategia algorítmica que busca todas las posibles soluciones dado un conjunto de variables inicial para encontrar el resultado definido por el problema. </ul>		
			<div class=" right-image" style="margin-right:600px;margin-left:50px ;">
				<img src="./image/unnamed.png"  width="300"alt="Algoritmo de ataques de fuerza bruta">
			</div>
		</div>
		<div>
			<dt style="font-size: 20px;margin-top: 80px;">En la tabla que veran a continuación colocaremos las ventajas y las desventajas de los algoritmos de ataque de fuerza bruta.</dt>
		</div>
		<div style="margin-top: 20px;margin-right: 500px;">
			<table>
				<th>Ventajas</th>
				<th>Desventajas</th>
				<tr>
					<td>Puede encontrar soluciones óptimas si está diseñado correctamente</td>
					<td>Puede ser muy lento y requiere mucho tiempo de procesamiento para problemas grandes</td>
				</tr>
				<tr>
					<td>Es eficiente en términos de memoria ya que utiliza una pila para almacenar soluciones parciales</td>
					<td>No garantiza que se encuentre una solución al problema</td>
				</tr>
				<tr>
					<td>Es útil para una amplia variedad de problemas, incluyendo problemas de optimización, búsqueda y decisión</td>
					<td>Puede encontrar múltiples soluciones, lo que puede ser un problema para algunos problemas</td>
				</tr>
				<tr>
					<td>Puede ser paralelizado fácilmente para mejorar el tiempo de ejecución</td>
					<td>La complejidad de la implementación aumenta con la complejidad del problema</td>
				</tr>
				<tr>
					<td>Puede ser utilizado en problemas que no se pueden resolver por fuerza bruta</td>
					<td>No es fácil determinar si un problema se puede resolver mediante backtracking o no</td>
				</tr>
				<tr>
					<td>Tiene una estructura recursiva simple que lo hace fácil de entender e implementar</td>
					<td>Puede requerir una gran cantidad de espacio de memoria para problemas complejos debido a la necesidad de almacenar soluciones parciales</td>
				</tr>
				<tr>
					<td>Puede encontrar soluciones subóptimas si se diseña de manera subóptima</td>
					<td>Es difícil evaluar el tiempo de ejecución para problemas grandes y complejos debido a su naturaleza recursiva.</td>
				</tr>
			</table>
			<div style="margin-right:300px;margin-top: 20PX;">
				<ul style="font-size: 20px;"> Funcionamiento del algoritmo backtracking</ul>
				<li>Definir el problema: se debe tener una idea clara del problema que se quiere resolver y de los posibles caminos que se pueden tomar para llegar a una solución.</li>
				<li>Definir el conjunto de soluciones: se deben identificar todas las posibles soluciones del problema, para lo cual se pueden utilizar diferentes técnicas como la enumeración, la generación de árboles o la exploración de grafos.</li>
				<li>Generar una solución: se debe generar una solución inicial y comprobar si es válida.</li>
				<li>Evaluar la solución: se debe evaluar la solución generada y determinar si cumple con los criterios de validez establecidos para el problema.</li>
				<li>Si la solución es válida, se debe guardar. En caso contrario, se debe descartar.</li>
				<li>Continuar explorando soluciones: se debe continuar generando y evaluando soluciones hasta encontrar una solución óptima o hasta agotar todas las posibilidades.</li>
				<li>Retroceder y explorar otras soluciones: si se alcanza un punto en el que no es posible continuar, se debe retroceder a la última decisión tomada y explorar otras soluciones a partir de ese punto.</li>
				<li>Repetir el proceso: se debe repetir el proceso hasta encontrar una solución óptima o hasta agotar todas las posibilidades.</li>
			</div>
			<div style="margin-top: 30px;">
				<p style="font-size: 30px;">Aqui un pequeño ejemplo del algoritmo de backtracking</p>
				<video width="640" height="360" controls style="margin-top: 10px;">
					<source src="./image/Algoritmia - Ejercicio Backtracking - Andrés Muñoz.mp4" type="video/mp4">
					Tu navegador no soporta la etiqueta de video.
				</video>
			</div>
		</div>
	</div>
	</div>
		
			<!--incio de div de programacion dinamica-->
			<div id="Programación-dinámica" class="info" style="background-color: #d4f0fc;">
		<h1 style="text-align: center;">Programación dinámica</h1>
		<div style="margin-left: 250px;margin-left: 250px">
			<div class="text-container">
				<ul style="margin-top: 90px;">La programación dinámica es un método de optimización que puede aplicarse a diferentes y numerosos problemas, algunos de los cuales ya han sido analizados en programación lineal y programación entera. Los parámetros usados en la programación dinámica pueden ser estocásticos o probabilísticos y determinísticos.
					La programación dinámica tiene como finalidad encontrar una solución de un problema de optimización en forma secuencial. A diferencia de la programación lineal, la programación entera no es un algoritmo de solución única, sino más bien un método para resolver un problema grande y único solventando una secuencia de problemas más pequeños, sin importar el número de ellos. La programación dinámica permite resolver un problema que depende del tiempo en forma de una continuidad de problemas de un sólo periodo, en donde los parámetros de cada periodo dependen del periodo que se considera; es posible que no se conozca la cuantificación de cada periodo sino hasta que éste llega. </ul>		
					<div class=" right-image" style="margin-right:500px;margin-left:50px ;">
						<img src="./image/images__1_-removebg-preview.png"  width="200"alt="Algoritmo de ataques de fuerza bruta" style="max-width: fit-content;">
					</div>
				</div>
				<div>
					<dt style="font-size: 20px;margin-top: 80px;">En la tabla que veran a continuación colocaremos las ventajas y las desventajas de la programación dinámica.</dt>
				</div>
			<div  style="margin-top: 20px;margin-right: 500px;">
				<table>
					<tr>
						<th>Ventajas</th>
						<th>Desventajas</th>
					</tr>
					<tr>
						<td>Permite resolver problemas complejos de manera eficiente</td>
						<td>Puede ser difícil de entender e implementar</td>
					</tr>
					<tr>
						<td>Evita cálculos repetitivos al almacenar subproblemas previamente resueltos</td>
						<td>Requiere de memoria adicional para almacenar los resultados previos</td>
					</tr>
					<tr>
						<td>Optimiza el tiempo de ejecución al evitar recalcular soluciones previas</td>
						<td>No siempre es la solución más óptima, ya que depende de la calidad de la función de evaluación utilizada</td>
					</tr>
					<tr>
						<td>Es útil en problemas de optimización y decisiones secuenciales</td>
						<td>Requiere de una estructura recursiva o iterativa para su implementación</td>
					</tr>
				</table>
			</div>
				<div style="margin-top: 30px;">
					<ul style="font-size: 20px;"> Funcionamiento de la programación dinámica</ul>
					<li>Caracterizar la estructura del problema: Identificar las subestructuras óptimas del problema y cómo están relacionadas entre sí.</li>
					<li>Definir la función de recursión: Escribir una función que defina la relación entre el problema original y sus subproblemas más pequeños.</li>
					<li>Implementar la función de recursión: Codificar la función de recursión utilizando una técnica de memoización para evitar recalculaciones innecesarias.</li>
					<li>Resolver el problema original: Utilizando la función de recursión para calcular la solución al problema original.</li>
					<li>Analizar la complejidad: Asegurarse de que la complejidad de la solución es aceptable para el tamaño de entrada del problema.</li>
				</div>
				<div style="margin-top: 30px;">
					<p style="font-size: 30px;">Aqui un pequeño ejemplo del algoritmo de Programación dinámica</p>
					<video width="640" height="360" controls style="margin-top: 10px;">
						<source src="./image/Programación dinámica. Problema de la Mochila..mp4" type="video/mp4">
						Tu navegador no soporta la etiqueta de video.
					</video>
				</div>
			</div>
			</div>
		</body>
            </html>
